'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _express = require('express');

var _express2 = _interopRequireDefault(_express);

var _bodyParser = require('body-parser');

var _bodyParser2 = _interopRequireDefault(_bodyParser);

var _morgan = require('morgan');

var _morgan2 = _interopRequireDefault(_morgan);

var _localtunnel = require('localtunnel');

var _localtunnel2 = _interopRequireDefault(_localtunnel);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_PORT = 5463; // LINE
var DEFAULT_ENDPOINT = '/';
var DEFAULT_TUNNEL = false;

var Webhook = function () {
  function Webhook(_ref) {
    var _this = this;

    var secret = _ref.secret,
        token = _ref.token,
        _ref$options = _ref.options,
        options = _ref$options === undefined ? {} : _ref$options,
        onEvents = _ref.onEvents,
        onWebhook = _ref.onWebhook,
        onTunnel = _ref.onTunnel;

    _classCallCheck(this, Webhook);

    this.secret = secret;
    this.token = token;
    this.onEvents = onEvents;
    this.events = 0;

    this._parseBody = this._parseBody.bind(this);
    this._getSignature = this._getSignature.bind(this);
    this._verifyRequest = this._verifyRequest.bind(this);
    this._createTunnel = this._createTunnel.bind(this);

    var app = (0, _express2.default)();
    var APP_PORT = options.port || DEFAULT_PORT;
    var APP_ENDPOINT = options.endpoint || DEFAULT_ENDPOINT;
    var APP_TUNNEL = options.tunnel || options.ngrok || DEFAULT_TUNNEL;
    var IS_VERIFY_SIGNATURE = options.verifySignature || false;

    app.use((0, _morgan2.default)('dev'));
    if (IS_VERIFY_SIGNATURE) {
      app.use(_bodyParser2.default.json({ verify: this._verifyRequest }));
      app.use(this._abortOnError);
    } else {
      app.use(_bodyParser2.default.json());
    }
    app.get(APP_ENDPOINT, function (req, res) {
      res.send('listening on port ' + APP_PORT + (', handled ' + _this.events + ' events.'));
    });
    app.post(APP_ENDPOINT, this._parseBody.bind(this));
    app.use(function (err, req, res, next) {
      console.log(err);
      res.status(500).send(err);
    });
    this._webserver = app;
    this._webserver.listen(APP_PORT, function (err) {
      if (!err) {
        onWebhook({ port: APP_PORT, endpoint: APP_ENDPOINT });
        if (APP_TUNNEL) {
          _this._createTunnel(APP_PORT).then(onTunnel).catch(onTunnel);
        }
      }
    }).on('error', function (err) {
      console.error(err);
    });
  }

  _createClass(Webhook, [{
    key: '_createTunnel',
    value: function _createTunnel(port) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var tunnel = (0, _localtunnel2.default)(port, function (err, _ref2) {
          var url = _ref2.url;

          if (err) {
            reject({ err: err });
          }
          resolve({ url: url });
        });
        _this2.tunnel = tunnel;
      });
    }
  }, {
    key: '_parseBody',
    value: function _parseBody(req, res, next) {
      var events = req.body && req.body.events;
      if (events) {
        // console.log(this)
        res.send('OK');
        this.onEvents(events, req);
        this.events++;
      } else {
        next('no events found');
        // return null
      }
    }
  }, {
    key: '_getSignature',
    value: function _getSignature(buf) {
      var hmac = _crypto2.default.createHmac('sha256', this.secret).update(buf, 'utf-8').digest('base64');
      return hmac;
    }
  }, {
    key: '_verifyRequest',
    value: function _verifyRequest(req, res, buf, encoding) {
      var lineHeaderName = 'X-Line-Signature';
      var lineHeader = lineHeaderName.toLowerCase();
      var expected = req.headers[lineHeader];
      var calculated = this._getSignature(buf);
      // console.log(`X-Line-Signature: ${expected}\nBody: ${buf.toString('utf8')}`)
      if (expected !== calculated) {
        throw new Error('Invalid signature.');
        // } else {
        // console.log('Valid Signature.')
      }
    }
  }, {
    key: '_abortOnError',
    value: function _abortOnError(err, req, res, next) {
      if (err) {
        console.log(err);
        res.status(400).send({ error: 'Invalid signature.' });
      } else {
        next();
      }
    }
  }]);

  return Webhook;
}();

exports.default = Webhook;